---
title: "并查集"
date: 2018-05-26T10:43:44+08:00
draft: false
author: ["zhannicholas"]
tags:
  - 算法
toc: True
categories: 
 - 《C算法》学习笔记
---

记录一下最近学习的并查集。

# 问题引入

假定有一个整数对序列，其中每个整数代表某种类型的一个对象，而且将 **`p-q`** 解释为“p与q连通”。关系是可传递的，如果 **`p-q`** 和 **`q-r`** ，则有
 **`p-r`** 。我们的目标是编写一段程序，从集合中过滤额外连接对。当程序输入一个连接对 **`p-q`** ，若之前的连接对不能通过传递关系推导出 **`p-q`** ，则输出
 **`p-q`** ， 否则忽略 **`p-q`** ，读取下一个整数对。

过程示例:

3-4    3-4

4-0    4-0

3-0

4-1    4-1

5-6    5-6

0-5    0-5

3-5

2-9    2-9

我们的问题是设计一个程序，它通过已有的信息，来判断新的对象是否连通。整数可能代表一个大型网络中的计算机，整数对可能代表网络中的连通情况。同样，整数也可以代表一个电网中的触电， 整数对就是电线……这些问题的规模可能都非常巨大，算法的好坏直接决定了开销的大小。

# 并和查

并查集主要有以下两个操作:

 1. 并： 合并两个集合
 2. 查： 判断两个元素是否属于同一个集合

# 解决方案

我们可以通过查找（union）和并集（union）运算来解决连通性问题。每当从输入读取一个新的 **`p-q`** 对后，分别进行 **`p`** 和 **`q`** 的查找， 如果它们位于同一个集合中，就直接分析下一个 **`p-q`** 对。否则，就进行并集操作并输出。
最可能想到的是依次保存每一个 **`p-q`** 对，然后进行遍历，判断它们是否连通。可问题的规模可能很大，这时候这个方法就捉襟见肘了。我们其实并不用保存所有的  **`p-q`** 对，使用一个整数数组来保存实现find和union操作的必备信息即可。

## 快速查找（quick-find）简单算法

> 假设A和B是朋友，B和C是朋友，A和B互不认识，但他们通过B这个共同的朋友联系在了一块儿。C还会有朋友D……,所有能通过某种朋友关系建立联系的朋友就构成了一个朋友圈。设想每个朋友圈都有一个圈主，圈主唯一的确定了这个圈子。为了简化问题，每当有一个新的人加入圈子，他就成为了这个圈子的圈主。
于是我们可以用一个数组 **`A[]`** 来进行存储。如果 **`i`** 代表一个人，那么 **`A[i]`** 就是他的圈主。现在我们来判断 **`p`** 和 **`q`** 是不是位于同一个圈子, 解决最开始提出的问题。

使用一个整数数组 **`A[]`** , 它具有如下性质：当且仅当 **`A[p] = A[q]`** 时，p与q连通。首先用 **`i`** 初始化 **`A[i]`** , 为了对 **`p`** 和 **`q`** 实现并集的运算，遍历数组，将所有和 **`A[p]`** 值相同项的替换为 **`A[q]`** 的值。

```C++
#include<cstdio>
const int N = 10000;

int main(){
    int p, q, A[N];
    for(int i = 0;i < N;i++) A[i] = i;
    while(scanf("%d-%d", &p, &q) == 2){
        if(A[p] == A[q]) continue;
        for(int i = 0, t = A[p];i < N;i++){
            if(A[i] == t) A[i] = A[q];
        }
        printf("%d-%d\n", p, q);
    }
}
```

可以用树来表示quick-find的过程。如下图中左半部分所示，每输入一个 **`p-q`** 对， **`A[q]`** 就成为父节点。下图的右半部分描述的是quick-union的过程， 每次只有一个值发生了改变。也就是 **`q`** 成为了 **`p`** 的父节点。
![union-and-find](/images/union-and-find.jpg)

## 快速并集（quick-union）算法

> 前面的快速查找算法能够正确解决问题，当面对百万级的输入，效率就不行了。下面是quick-find的互补方法——quick-union。
可以用树来描述描述p和q是不是位于同一个集合，如果p和q有相同的根节点，那么他们位于同一个集合。如果p和q不在同一个集合中，
为了形成并集，使p和q拥有相同的根节点即可。
> 和quick_find的不同在于：
* 这里 **`A[i]`** 的值指向的是它的父亲在数组中的下标（比如 **`A[1] = 2`** ， 1的父亲在数组中的下标为2）。
* 根节点的值指向它本身，即：若 **`i`** 为根节点，则 **`A[i] = i`** ;根节点总是存在的。
* 通过分别通过 **`i`** 和 **`j`** 递归查找 **`p`** 和 **`q`** 的根节点。

用下面的代码替换quick-find中的 **`while`** 循环体

```C++
int i , j;
for(i = p;i != A[i];i = A[i]);
for(j = q;j != A[j];j = A[j]);
if(i == j) continue;  //p和q的根相同，说明p和q连通
A[i] = j;  // 进行并集操作
printf("%d-%d\n", p, q);
```

## 加权快速并集（weighted-quick-union）算法

> quick-union是对quick-find的一种改进，但仍然有缺陷。每次进行并集操作就相当于把一棵树的树根链接到另一棵树的树根上去。
而找到根节点所化的时间和当前结点到根节点的距离有关，距离越短，for循环执行的次数就越少
如果能够直接把较小的树的根直接连接到较大的树的根上，就能缩短时间。
于是我们可以设置辅助数组 **`S[]`** 来跟踪每个结点子树中结点的数量，然后总是把较小的树的根连接到较大的树的根上去。

```C++
#include<cstdio>
const int N = 10000;

int main(){
    int p, q, A[N], S[N];
    for(int i = 0;i < N;i++){A[i] = i;S[N] = 1;}
    while(scanf("%d-%d", &p, &q) == 2){
        int i , j;
        for(i = p;i != A[i];i = A[i]);
        for(j = q;j != A[j];j = A[j]);
        if(i == j) continue;  //p和q的根相同，说明p和q连通
        A[i] = j;  // 进行并集操作
        if(S[i] < S[j]){A[i] = j;S[j] += S[i];}  // 寻找大树
        else {A[j] = i;S[i] += S[j];}
        printf("%d-%d\n", p, q);
    }
}
```

## 路径压缩

> 如果能够在并集操作中，使每个结点都能直接指向树根，那么将大大节省开销。最终的结果就是几乎把整棵树压平，接近于理想情况。
可以对上面的算法做一个简单的改进——通过某种方法让 **`A[i]`** 存储的不再是它父亲在数组中的下标，而是越过父节点更靠近根节点的结点在数组中的下标。比如父结点的父节点。

对代码进行一下调整：

```C++
for(i = p;i != A[i];i = A[i]) A[i] = A[A[i]];
for(j = q;j != A[j];j = A[j]) A[i] = A[A[i]];
```
